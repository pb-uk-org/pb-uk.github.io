<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visualizing sorting algorithms</title>
    <meta name="description" content="Paul&#39;s home page miscellany.">

    <link rel="stylesheet" href="/assets/css/prism/prism-solarizedlight.css">
    <link rel="alternate" href="/feed/feed.xml" type="application/atom+xml" title="PB UK">
    <link rel="alternate" href="/feed/feed.json" type="application/json" title="PB UK">

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/buefy/dist/buefy.min.css">
    <!-- link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.9/css/bulma.css" -->


    <script async src="https://cdn.jsdelivr.net/npm/vue@2"></script>
    <!-- Full bundle -->
    <script async src="https://cdn.jsdelivr.net/npm/buefy/dist/buefy.min.js"></script>
    <script>window.addEventListener('load',function() {Vue && vueApp && new Vue(vueApp)})</script>


    <link rel="stylesheet" href="/assets/css/index.css">

  </head>
  <body>
    
    

<nav role="navigation" aria-label="main navigation" class="navbar is-primary">
  <div class="container">
    <div class="navbar-brand">
      <a class="navbar-item" href="/">PB UK</a>
      <a class="navbar-item" href="/articles/">Articles</a>
      <a class="navbar-item" href="/blog/">Blog</a>
      <a class="navbar-item" href="/tags/">Tags</a>
      <a class="navbar-item" href="/about/">About</a>

    </div>
  </div>
</nav>


    <section class="section py-0">
      <div class="container">
        
<nav class="breadcrumb my-3 is-size-7" aria-label="breadcrumbs">
  <ul>

  
    
      <li>In <a class="px-1" href="/algorithms/">algorithms</a></li>
    
  

  
    
      <li><a class="px-1" href="/algorithms/sorting/">sorting</a></li>
    
  

  
    
  

  </ul>
</nav>

<main class="content">

<h1>Visualizing sorting algorithms</h1>

<div id="app"></div>


<script type="text/x-template" id="app-template">
<div>
  <div>
    <div v-for="(algorithm, i) in algorithms" class="columns is-multiline">
      <div class="column is-12">
        <h3>{{ algorithm.name }}</h3>
      </div>
      <div v-for="(set, j) in sets" class="column">
        <h4 class="my-0">{{ set.name }}</h4>
        <div v-if="logData">
          Compares: {{ logData[`${i}-${j}`].compares }}
          swaps: {{ logData[`${i}-${j}`].swaps }}
        </div>
        <div v-bind:ref="`canvas-${i}-${j}`"></div>
      </div>
    </div>
  </div>
</div>
</script>


<script>

/* eslint-env browser */

class Chart {
  constructor({ $el, n, max, height, width }) {
    // Set the dimensions for the canvas.
    // These are fixed as integer multiples of n so it looks good.
    this.n = n;
    this.max = max;
    this.xScale = Math.floor(width / n);
    this.yScale = Math.floor(height / max);

    this.width = this.xScale * n;
    this.height = this.yScale * max;

    $el.innerHTML = `<canvas width="${this.width}" height="${this.height}"></canvas>`;
    this.ctx = $el.firstChild.getContext('2d');
 
    this.last = false;
    this.colours = {
      background: '#efefef',
      normal: '#afafaf',
      swap: '#9f0000',
      compare: '#007f00',
    };
  }

  draw(aIndex, aValue, bIndex, bValue, swap) {
    const { xScale, yScale, height } = this;

    if (this.last) {
      const [ai, av, bi, bv, sw] = this.last;
      if (sw > 0) {
        // They were swapped so paint out the old positions.
        this.ctx.fillStyle = this.colours.background;
        this.ctx.fillRect(ai * xScale, height - av * yScale, xScale, height);
        this.ctx.fillRect(bi * xScale, height - bv * yScale, xScale, height);
        // Paint the new positions in in grey.
        this.ctx.fillStyle = this.colours.normal;
        this.ctx.fillRect(ai * xScale, height - bv * yScale, xScale, height);
        this.ctx.fillRect(bi * xScale, height - av * yScale, xScale, height);
      } else {
        // They were not swapped so just repaint in grey.
        this.ctx.fillStyle = this.colours.normal;
        this.ctx.fillRect(ai * xScale, height - av * yScale, xScale, height);
        this.ctx.fillRect(bi * xScale, height - bv * yScale, xScale, height);
      }
    }

    if (swap > 0) {
      // They will be swapped so repaint in red.
      this.ctx.fillStyle = this.colours.swap;
      this.ctx.fillRect(aIndex * xScale, height - aValue * yScale, xScale, height);
      this.ctx.fillRect(bIndex * xScale, height - bValue * yScale, xScale, height);
    } else {
      // They are not going to be swapped so repaint in green.
      this.ctx.fillStyle = this.colours.compare;
      this.ctx.fillRect(aIndex * xScale, height - aValue * yScale, xScale, height);
      this.ctx.fillRect(bIndex * xScale, height - bValue * yScale, xScale, height);
    }

    // Remember what we did for next time.
    this.last = [ aIndex, aValue, bIndex, bValue, swap ];
  }

  repaint(set) {
    const { xScale, yScale, height, width } = this;

    // Paint out everything.
    this.ctx.fillStyle = this.colours.background;
    this.ctx.fillRect(0, 0, width, height);

    this.ctx.fillStyle = this.colours.normal;
    set.forEach((value, i) => {
      // Paint the new positions in in grey.
      this.ctx.fillRect(i * xScale, height - value * yScale, xScale, height);
    });
  }
}

/* eslint-disable-next-line no-unused-vars*/
class Visualizations {
  constructor({ render, log, fps }) {
    this.allDone = false;
    this.fps = fps != null ? fps : false;
    this.visualizations = [];
    this.log = log;
    if (render) this.render = render;
  }

  add(options) {
    this.visualizations.push(new Visualization({
      log: this.log,
      ...options,
    }));
  }

  renderAll(repaint) {
    this.visualizations.forEach(vis => {
      this.render(vis, vis.set, vis.isDone, repaint);
      this.log(vis.id, vis);
    });
  }

  render() {} // ({ compare, swap, set }, value, done, repaint) {

  step() {
    if (this.allDone) return;
    let allDone = true;
    this.visualizations.forEach(vis => {
      if (vis.isDone) return;
      const { done, value } = vis.next();
      vis.isDone = done;
      this.render(vis, value, done);
      allDone &= done;
    });
    this.allDone = allDone;
  }

  iterate() {
    if (this.allDone) return;
    this.step();
    if (this.allDone) {
      setTimeout(() => {
        this.renderAll(true);
      }, this.fps === false ? 0 : 1000 / this.fps);
    }
    setTimeout(() => this.iterate(), this.fps === false ? 0 : 1000 / this.fps);
  }
}

class Visualization {
  constructor({
    generatorFunction,
    render,
    set,
    chart,
    id,
  }) {
    this.id = id;
    this.compare = new Compare();
    this.swap = new Swap();
    this.render = render;
    this.set = set;
    this.chart = new Chart(chart);

    // The visualisation is a generator function.
    this.generator = generatorFunction(set, {
      compare: this.compare.compare,
      swap: this.swap.swap,
    });

    this.algorithm = 'Improved bubble sort';
    this.initial = 'Reversed';
  }

  next() {
    return this.generator.next();
  }
}

class Compare {
  constructor() {
    this.count = 0;
    this.last = [null, null, null];

    function compare(set, a, b) {
      ++this.count;
      const result = set[a] > set[b] ? 1 : (set[a] < set[b] ? -1 : 0);
      this.last = [a, b, result];
      return result;
    }
    this.compare = compare.bind(this);
  }
}

class Swap {
  constructor() {
    this.count = 0;
    this.last = [null, null];

    function swap(set, a, b) {
      ++this.count;
      this.last = [a, b];
      const temp = set[a];
      set[a] = set[b];
      set[b] = temp;
    }
    this.swap = swap.bind(this);
  }
}

/* eslint-disable-next-line no-unused-vars*/
function shuffle(array) {
  var currentIndex = array.length, temporaryValue, randomIndex;

  // While there remain elements to shuffle...
  while (0 !== currentIndex) {

    // Pick a remaining element...
    randomIndex = Math.floor(Math.random() * currentIndex);
    currentIndex -= 1;

    // And swap it with the current element.
    temporaryValue = array[currentIndex];
    array[currentIndex] = array[randomIndex];
    array[randomIndex] = temporaryValue;
  }

  return array;
}
;

const algorithms = [];
let fn;

  fn = function* improvedBubbleSortGenerator(set, { compare, swap }) {
  let n = set.length;
  // Start comparing at the end for better performance when nearly sorted.
  for (let i = n - 1; i > 0; --i) {
    // Bubble towards the start.
    for (let j = n - 1; j > n - i - 1; --j) {
      if (compare(set, j - 1, j) > 0) {
        yield set;
        swap(set, j - 1, j);
      } else {
        yield set;
      }
    }
    // The (n - i - 1)'th element is now correct.
  }
  return set;
}

/*
function* improvedBubbleSortGenerator(set, { compare, swap }) {
  let n = set.length;
  for (let i = n - 1; i > 0; --i) {
    for (let j = n - i + 1; j >= 0; --j) {
      if (compare(set, j, j + 1) > 0) {
        yield set;
        swap(set, j, j + 1);
      } else {
        yield set;
      }
    }
  }
  return set;
}
*/
;
  algorithms.push({
    name: 'Improved bubble sort',
    fn,
  });

  fn = function* improvedBubbleSortGenerator(set, { compare, swap }) {
  let n = set.length;
  // Start comparing at the end for better performance when nearly sorted.
  for (let i = n - 1; i > 0; --i) {
    // Bubble towards the start.
    for (let j = n - 1; j > n - i - 1; --j) {
      if (compare(set, j - 1, j) > 0) {
        yield set;
        swap(set, j - 1, j);
      } else {
        yield set;
      }
    }
    // The (n - i - 1)'th element is now correct.
  }
  return set;
}

/*
function* improvedBubbleSortGenerator(set, { compare, swap }) {
  let n = set.length;
  for (let i = n - 1; i > 0; --i) {
    for (let j = n - i + 1; j >= 0; --j) {
      if (compare(set, j, j + 1) > 0) {
        yield set;
        swap(set, j, j + 1);
      } else {
        yield set;
      }
    }
  }
  return set;
}
*/
;
  algorithms.push({
    name: 'Improved bubble sort 2',
    fn,
  });

  fn = function* improvedBubbleSortGenerator(set, { compare, swap }) {
  let n = set.length;
  // Start comparing at the end for better performance when nearly sorted.
  for (let i = n - 1; i > 0; --i) {
    // Bubble towards the start.
    for (let j = n - 1; j > n - i - 1; --j) {
      if (compare(set, j - 1, j) > 0) {
        yield set;
        swap(set, j - 1, j);
      } else {
        yield set;
      }
    }
    // The (n - i - 1)'th element is now correct.
  }
  return set;
}

/*
function* improvedBubbleSortGenerator(set, { compare, swap }) {
  let n = set.length;
  for (let i = n - 1; i > 0; --i) {
    for (let j = n - i + 1; j >= 0; --j) {
      if (compare(set, j, j + 1) > 0) {
        yield set;
        swap(set, j, j + 1);
      } else {
        yield set;
      }
    }
  }
  return set;
}
*/
;
  algorithms.push({
    name: 'Improved bubble sort 3',
    fn,
  });

  fn = function* improvedBubbleSortGenerator(set, { compare, swap }) {
  let n = set.length;
  // Start comparing at the end for better performance when nearly sorted.
  for (let i = n - 1; i > 0; --i) {
    // Bubble towards the start.
    for (let j = n - 1; j > n - i - 1; --j) {
      if (compare(set, j - 1, j) > 0) {
        yield set;
        swap(set, j - 1, j);
      } else {
        yield set;
      }
    }
    // The (n - i - 1)'th element is now correct.
  }
  return set;
}

/*
function* improvedBubbleSortGenerator(set, { compare, swap }) {
  let n = set.length;
  for (let i = n - 1; i > 0; --i) {
    for (let j = n - i + 1; j >= 0; --j) {
      if (compare(set, j, j + 1) > 0) {
        yield set;
        swap(set, j, j + 1);
      } else {
        yield set;
      }
    }
  }
  return set;
}
*/
;
  algorithms.push({
    name: 'Improved bubble sort 4',
    fn,
  });


const sets = []

  sets.push({
    name: 'Random',
    generator: 'random',
  });

  sets.push({
    name: 'Nearly sorted',
    generator: 'nearlySorted',
  });

  sets.push({
    name: 'Reversed',
    generator: 'reversed',
  });

  sets.push({
    name: 'Many equal',
    generator: 'random',
  });


function render({ compare, swap, set, chart, id }, value, done, repaint) {
  if (repaint) {
    chart.repaint(set);
    return;
  }
  const { last } = compare;
  chart.draw(last[0], set[last[0]], last[1], set[last[1]], last[2]);
  this.log(id, { compare, swap});
}

const max = 100;

function createVisualisations({ targets, algorithms, sets }) {
  const logData = {};
  sets.forEach((setDef, i) => {
    const set = getSet[setDef.generator]();
    algorithms.forEach((algorithm, j) => {
      const id = `${j}-${i}`;
      logData[id] = { compares: null, swaps: null };
      this.visualizations.add({
        id,
        generatorFunction: algorithms[j].fn,
        set: set.slice(),
        chart: {
          $el: targets[j][i],
          n: set.length,
          max,
          height: 100,
          width: 300,
        },
      });
    });
    this.logData = logData;
  });
}

const getSet = {
  sorted() {
    const set = [];
    for (let i = 1; i <= max; ++i) {
      set.push(i);
    }
    return set;
  },
  random() {
    const set = [];
    for (let i = 1; i <= max; ++i) {
      set.push(i);
    }
    return shuffle(set);
  },
  nearlySorted() {
    const set = this.sorted();
    const first = set.shift();
    set.push(first);
    return set;
  },
  reversed() {
    return this.sorted().reverse();
  },
};

vueApp = {
  el: '#app',
  template: '#app-template',
  data() {
    return {
      algorithms: algorithms,
      title: 'My title',
      message: 'loaded',
      compares: {},
      swaps: {},
      logData: null,
    };
  },
  methods: {
    createTargets() {
      const targets = [];
      for (let i = 0; i < algorithms.length; ++i) {
        targets.push([]);
        for (let j = 0; j < sets.length; ++j) {
          targets[i].push(this.$refs[`canvas-${i}-${j}`][0]);
        }
      }
      return targets;
    }, // createTargets()

    createVisualisations,

    log(id, data) {
      this.logData[id].compares = data.compare.count;
      this.logData[id].swaps = data.swap.count;
    }, // log()
  },
  mounted() {
    const targets = this.createTargets();
    const log = (id, data) => {
      this.log(id, data);
    };
    this.visualizations = new Visualizations({ render, log });
    this.createVisualisations({ targets, algorithms, sets });
    this.visualizations.renderAll(true);
    this.visualizations.iterate();
  }, // mounted()
}
</script>

</main>
<hr>
<div class="columns pb-5">
  <div class="column is-size-7 py-0">Previous: <a href="/algorithms/sorting/visualization/old/">Old visualizing sorting algorithms</a>
  </div>
  <div class="column has-text-right is-size-7 py-0">
  </div>
</div>

      </div>
    </section>

    <footer
      class="footer has-text-centered is-size-7 py-1"
      ><a href="/about/#copyright">Copyright © 2020 PBUK</a></footer>

    <!-- Current page: /algorithms/sorting/visualization/ -->
  </body>
</html>
